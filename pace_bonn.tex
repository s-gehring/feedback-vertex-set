\documentclass[11pt,a4paper]{scrartcl}
\usepackage[english]{babel}

\begin{document}
\title{Documentation}
\subtitle{PACE 2016 - Track B: Feedback Vertex Set}
\author{Fabian Brand, Simon Gehring, Florian Nelles,\\ Kevin Wilkinghoff, Xianghui Zhong\\
	supervised by: Stefan Fafianie, Stefan Kratsch}
\maketitle

First, we apply basic preprocessing procedures as deleting all vertices with self-loops and deleting all vertices with degree strictly smaller than 2. The next step is to iteratively remove semidisjoint cycle. There, it is clear that taking the single vertex with degree greater two is always optimal. After that, the graph is split into all connected components it consists of. All of these are solved independently since this grants an exponential reduction of runtime. Now we check whether the degree of each vertex of the graph is three or smaller because these instances can be solved in polynomial time by applying ??????????????. After that, every connected component's edges are contracted and all the multiedges which are created by this procedure are stored. Since some multiedges may be overlapping, the last preprocessing step is to create a graph consisting only of the multiedges and detect all minimal vertex covers by a recursive procedure. These minimal vertex covers correspond to all the different multiedge branchings which need to be considered and all of them are tested for finding the best solution.
\par 
Now, the main part of the algorithm is applied: the iterative compression algorithm which is presented in \cite{chen2008}. Within this algorithm, the approximative solution is computed with the algorithm given in \cite{bafna1999}. There is only one minor change: Instead of taking the whole semidisjoint cycle into the unreduced approximate solution in every step, we only take the vertex which has degree greater than two instead of taking the whole semidisjoint cycle. It is obvious that this is still optimal but saves a tiny bit of runtime. Whenever we make use of algorithm 1 given in \cite{chen2008}, we first solve all the vertices with highest degree until there are only vertices with degree smaller or equal three left. The reason for this is that we want to apply the degree three case algorithm as often as possible.

\section{Degree 3 Case}

We detect and solve the degree 3 special case in polynomial time as described in \cite{DBLP:journals/corr/abs-1004-1672}. We call an instance a \textit{degree 3 case}, if in the problem $DISJOINT-FVS(G; V_1, V_2; k)$ all vertices of $V_1$ have degree 3 or smaller, where $V_2$ is a FVS of G of size k+1 and we want to compute a FVS completely in $V_1$ of size k. The DISJOINT-FVS problem appears in the iterative compression.


The key idea is the following: If we consider a $G[V_2]$-spanning tree $T$, every edge in $G - E[T]$ creates a cycle. A $V_1-adjacency-matching$ is a partition of those edge in $G - E[T]$ in groups of one or two edges and every group of two edges share an endpoint in $V_1$. We are searching for a $G[V_2]$-spanning tree that maximizes the number of two-groups. Then we put for every two-group the shared vertex and for every one-group an arbitrary vertex into the FVS. This is showed to be an optimal FVS in \cite{DBLP:journals/corr/abs-1004-1672}. To get this best $G[V_2]$-spanning tree $T$ we reduce this problem to a cographic matroid parity problem of an auxiliary graph described in Section 3 of the paper. The cographic version is itself solved by a linear matroid parity algorithm as described in \cite{Cheung:2014:AAL:2620785.2601066}. To get a huge speedup in the algorithm, we use the small rank update formula by Sherman, Morrison and Woodbury to check if a matrix is non-singular. All entries of the matrices are taken over a finite field to get exact calculation. We used the Galois field structure to get a good performance.



\addcontentsline{toc}{section}{literature}
\nocite{bafna1999}
\nocite{chen2008}
\bibliography{literature}
\bibliographystyle{abbrv}

\end{document}
