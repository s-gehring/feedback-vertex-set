\documentclass[11pt,a4paper]{scrartcl}
\usepackage[english]{babel}
\usepackage{amsmath}

\begin{document}
\title{Documentation}
\subtitle{Rheinische Friedrich-Wilhelms-Universit\"at Bonn}
\author{Fabian Brand, Simon Gehring, Florian Nelles,\\ Kevin Wilkinghoff, Xianghui Zhong\\
	supervised by: Stefan Fafianie, Stefan Kratsch}
\maketitle

\section{General case}
First, we apply basic preprocessing procedures as deleting all vertices with self-loops and deleting all vertices with degree strictly smaller than two. 
The next step is to iteratively remove semidisjoint cycles, which are cycles from which at most one vertex has degree greater two. There exists always an optimal solution containing this higher degree vertex. Afterwards the graph is cut along all its containing bridges, potentially creating new connected components. Notice that a bridge is never part of a cycle and thus is safe to remove. We solve the feedback-vertex-set for each connected component separately and union all local solutions.
After this preprocessing we check whether the degree of each vertex of the graph is three or smaller since these instances can be solved in polynomial time by applying the procedure explained below. 
If the resulting graph contains vertices with a higher degree, we furthermore try to minimize it via edge contractions. For this step we take a vertex with degree two and replace it by an edge connecting its neighbors, possibly creating multiedges. Notice that for every such multiedge, we need at least one of its vertices. Since some multiedges may be overlapping, the last preprocessing step is to create a graph consisting only of the multiedges and detect all minimal vertex covers by a recursive procedure. These minimal vertex covers correspond to all the different multiedge branchings which need to be considered and all of them are tested for finding the best solution.
\par 
Now, the main part of the algorithm is applied: the iterative compression algorithm which is presented in \cite{chen2008}. Within this algorithm, the approximative solution is computed with the algorithm given in \cite{bafna1999}. There is only one minor change: Instead of taking the whole semidisjoint cycle into the unreduced approximate solution in every step, we only take the vertex which has degree greater than two instead of taking the whole semidisjoint cycle. It should be obvious that this is still optimal. Whenever we make use of algorithm 1 given in \cite{chen2008}, we first solve all the vertices with highest degree until there are only vertices with degree smaller or equal three left. The reason for this is that we want to apply the polynomial time degree three case algorithm as often as possible.

\section{Degree Three Case}

We detect and solve the degree three special case in polynomial time as described in \cite{DBLP:journals/corr/abs-1004-1672}. We call an instance a \textit{degree three case}, if in the problem $DISJOINT-FVS(G; V_1, V_2; k)$ all vertices of $V_1$ have degree three or smaller, where $V_2$ is a FVS of $G$ of size $k+1$ and we want to compute a FVS completely in $V_1$ of size $k$. The DISJOINT-FVS problem appears in the iterative compression.


The key idea is the following: If we consider a $G[V_2]$-spanning tree $T$, every edge in $G - E[T]$ creates a cycle. A $V_1-adjacency-matching$ is a partition of those edge in $G - E[T]$ in groups of one or two edges and every group of two edges share an endpoint in $V_1$. We are searching for a $G[V_2]$-spanning tree that maximizes the number of two-groups. Then we put for every two-group the shared vertex and for every one-group an arbitrary vertex into the FVS. This is showed to be an optimal FVS in \cite{DBLP:journals/corr/abs-1004-1672}. To get this best $G[V_2]$-spanning tree $T$ we reduce this problem to a cographic matroid parity problem of an auxiliary graph described in Section 3 of the paper. The cographic version is itself solved by a linear matroid parity algorithm as described in \cite{Cheung:2014:AAL:2620785.2601066}. To get a huge speedup in the algorithm, we use the small rank update formula by Sherman, Morrison and Woodbury to check if a matrix is non-singular.
%All indeterminates of the matrices are taken random values over a finite field to get exact calculation. The galois fields have size $2^{64}$. 
In every call of the degree three routine we plug in random numbers of a finite field with size $2^{63}$ for the indeterminates and calculate the maximum full rank submatrix. If the full rank submatrix is not the entire matrix we generate new random numbers and check if we get the same result. If not, we repeat the whole routine. The size of the matrix is the difference of edges to the nodes, this is smaller than the number of edges. We know that the instances have at most 90000 edges, thus the size of the matrix is also bounded by this number. So by the Schwarz-Zippel Lemma the failure probability is bounded by $\frac{90000}{2^{64}}$. Since we generate random numbers twice in every call, we can bound it to $(\frac{90000}{2^{64}})^2$. The clock signal of the processor is 3.6 GHz, therefore it can perform $3.6\cdot 10^9\cdot 1800<10^{15}$ operations in 30 minutes, hence our routine is executed less then $10^{15}$ times in 30 minutes. The overall failure probability is bounded by
\begin{align*}
1-\left(1-\left(\frac{90000}{2^{64}}\right)^2\right)^{10^{15}}<10^{-12}
\end{align*}
as desired.

\addcontentsline{toc}{section}{literature}
\nocite{bafna1999}
\nocite{chen2008}
\bibliography{literature}
\bibliographystyle{abbrv}

\end{document}
