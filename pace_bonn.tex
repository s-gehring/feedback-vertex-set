\documentclass[11pt,a4paper]{scrartcl}
\usepackage[english]{babel}

\begin{document}
\title{Documentation}
\subtitle{PACE 2016 - Track B: Feedback Vertex Set}
\author{Fabian Brand, Simon Gehring, Florian Nelles,\\ Kevin Wilkinghoff, Xianghui Zhong\\
	supervised by: Stefan Fafianie, Stefan Kratsch}
\maketitle

First, we apply basic preprocessing procedures as deleting all vertices with self-loops and deleting all vertices with degree strictly smaller than 2. The next step is to iteratively remove semidisjoint cycle. There, it is clear that taking the single vertex with degree greater two is always optimal. After that, the graph is split into all connected components it consists of. All of these are solved independently since this grants an exponential reduction of runtime. Now we check whether the degree of each vertex of the graph is three or smaller because these instances can be solved in polynomial time by applying ??????????????. After that, every connected component's edges are contracted and all the multiedges which are created by this procedure are stored. Since some multiedges may be overlapping, the last preprocessing step is to create a graph consisting only of the multiedges and detect all minimal vertex covers by a recursive procedure. These minimal vertex covers correspond to all the different multiedge branchings which need to be considered and all of them are tested for finding the best solution.
\par 
Now, the main part of the algorithm is applied: the iterative compression algorithm which is presented in \cite{chen2008}. Within this algorithm, the approximative solution is computed with the algorithm given in \cite{bafna1999}. There is only one minor change: Instead of taking the whole semidisjoint cycle into the unreduced approximate solution in every step, we only take the vertex which has degree greater than two instead of taking the whole semidisjoint cycle. It is obvious that this is still optimal but saves a tiny bit of runtime. Whenever we make use of algorithm 1 given in \cite{chen2008}, we first solve all the vertices with highest degree until there are only vertices with degree smaller or equal three left. The reason for this is that we want to apply the degree three case algorithm as often as possible.

\section{Degree 3 Case}

We detect and solve the degree 3 special case in polynomial time as described in \cite{DBLP:journals/corr/abs-1004-1672}. Whenever we detect in the iterated compression that all vertices in $V_1$ have degree at most 3, we first delete all vertices with degree 1 or less that were created by the branching process and then consider every connected component seperately. We reduce this special case to the cographic matroid parity problem of the auxility graph described in Section 3 of the paper. To solve this problem, we reduce it to the colinear matroid parity problem by generating the incidence matrix and transfer it to the linear parity problem. Here the entries of the matrix are taken in finite fields to allow for exact calculations. In the end we solve the linear parity problem by \cite{Cheung:2014:AAL:2620785.2601066}. The idea is based on the theorem of Lovasz. The galois fields have size $2^{16}$, so by the .

\addcontentsline{toc}{section}{literature}
\nocite{bafna1999}
\nocite{chen2008}
\bibliography{literature}
\bibliographystyle{abbrv}

\end{document}
